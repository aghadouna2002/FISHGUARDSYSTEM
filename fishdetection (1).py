# -*- coding: utf-8 -*-
"""fishdetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sXmcqNIzHhWfnaXtjwAdpJQacUKExhG3
"""

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="XHO9YXB20qjKphxCds58")
project = rf.workspace("fishspecies-izp5w").project("fish-detection-fztlb-h5ean")
version = project.version(1)
dataset = version.download("yolov11")

import os
HOME = os.getcwd()
print(HOME)

# Path to the dataset
dataset_path = '/content/Fish-Detection-1/'

# Initialize a dictionary to count the number of files in each subset
subset_counts = {'train': 0, 'test': 0, 'valid': 0}

# Walk through train, test, and valid directories to count files
for subset in ['train', 'test', 'valid']:
    subset_path = os.path.join(dataset_path, subset)
    for dirname, _, filenames in os.walk(subset_path):
        for filename in filenames:
            if filename.endswith('.txt'):  # Only count .txt files
                subset_counts[subset] += 1

# Print the number of images in each subset (train, test, valid)
print(f"Training set size: {subset_counts['train']}")
print(f"Test set size: {subset_counts['test']}")
print(f"Validation set size: {subset_counts['valid']}")

import yaml
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter

# Read class names from the data.yaml file
with open(os.path.join(dataset_path, 'data.yaml'), 'r') as file:
    class_names = yaml.safe_load(file)['names']

# Collect label IDs from .txt files in train, test, and valid directories
labels = [
    int(line.split()[0])
    for subset in ['train', 'test', 'valid']
    for dirname, _, filenames in os.walk(os.path.join(dataset_path, subset))
    for filename in filenames if filename.endswith('.txt')
    for line in open(os.path.join(dirname, filename)).readlines() if line.strip()
]

# Count occurrences of each class
class_counts = Counter(class_names[label] for label in labels)

# Set pastel color palette
sns.set_palette("pastel")

# Plot class distribution with a bar chart
plt.figure(figsize=(10, 6))
sns.barplot(x=list(class_counts.keys()), y=list(class_counts.values()))
plt.xlabel('Fish Species')
plt.ylabel('Frequency')
plt.title('Class Distribution of the Dataset')
plt.xticks(rotation=90)
plt.show()

import os
import cv2
import random
import matplotlib.pyplot as plt

# Paths
train_img_dir = '/content/Fish-Detection-1/train/images'
train_labels_dir = '/content/Fish-Detection-1/train/labels'

# Manually define class names since you don't have a YAML file
label_list = ['AngelFish', 'BlueTang', 'ButterflyFish','ClownFish','GoldFish','Gourami','MorishIdol','PlatyFish','RibbonedSweetlips','ThreeStripedDamselfish','YellowCichlid','YellowTang','ZebraFish']  # Update these names according to your classes

# Group images by class
images_by_class = {class_name: [] for class_name in label_list}
for img_name in os.listdir(train_img_dir):
    label_file = os.path.join(train_labels_dir, img_name[:-3] + 'txt')
    if os.path.exists(label_file):
        # Read the label file only once
        content = open(label_file, 'r').read().strip()
        if content:
            class_id = int(content.split()[0])
            images_by_class[label_list[class_id]].append(img_name)

# Select random images from each class (up to 12 images in total)
random_images = [random.choice(imgs) for imgs in images_by_class.values() if imgs][:12]

# Display random images
fig, axes = plt.subplots(4, 3, figsize=(11, 11))
for i, img_name in enumerate(random_images):
    ax = axes[i // 3, i % 3]
    img_path = os.path.join(train_img_dir, img_name)
    img = cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB)
    ax.imshow(img)

    label_file = os.path.join(train_labels_dir, img_name[:-3] + 'txt')
    content = open(label_file, 'r').read().strip()
    class_id = int(content.split()[0])
    ax.set_title(label_list[class_id])
    ax.axis('off')

plt.tight_layout()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %pip install ultralytics supervision roboflow
import ultralytics
ultralytics.checks()

from google.colab import files
uploaded = files.upload()

!ls

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle competitions list

# Commented out IPython magic to ensure Python compatibility.
!mkdir -p /content/datasets
# %cd /content/datasets

!pip install roboflow --quiet
from roboflow import Roboflow

# Replace YOUR_ROBOFLOW_API_KEY with your actual API key
rf = Roboflow(api_key="XHO9YXB20qjKphxCds58")
project = rf.workspace("zehra-acer").project("fish-detection-fztlb")
version = project.version(5)
dataset = version.download("yolov11")

!pip install ultralytics

from ultralytics import YOLO
model= YOLO('yolo11m.pt')

!nvidia-smi

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!yolo task=detect mode=train model=yolo11s.pt data={dataset.location}/data.yaml epochs=30 imgsz=640 plots=True

list_of_metrics = ["R_curve.png", "confusion_matrix.png", "results.png"]

import matplotlib.pyplot as plt

from PIL import Image
for i in list_of_metrics:

    image = Image.open(f'/content/runs/detect/train/{i}')

    plt.figure(figsize=(12, 8))
    plt.axis("off")
    plt.imshow(image)
    plt.show()

!yolo task=detect mode=val model=/content/runs/detect/train/weights/best.pt data={dataset.location}/data.yaml

input_video_path = "/content/inputvideo.mp4"
output_video_path = "/content/outputvideo.mp4"
!yolo task=detect mode=predict model=/content/runs/detect/train/weights/best.pt conf=0.25 source="{input_video_path}" save=True

!ls runs/detect/predict2/

input_video = 'runs/detect/predict2/inputvideo.avi'
output_video = 'runs/detect/predict2/Dream_Aquarium_Pred.mp4'

!ffmpeg -i runs/detect/predict2/inputvideo.avi -vcodec libx264 runs/detect/predict2/Dream_Aquarium_Pred.mp4
os.system(ffmpeg_command)

!ls runs/detect/predict2/

pred_video_path = 'runs/detect/predict2/Dream_Aquarium_Pred.mp4'

mp4 = open(pred_video_path, 'rb').read()
data_url = "data:video/mp4;base64," + base64.b64encode(mp4).decode()

HTML(f"""
<video width=600 controls>
      <source src="{data_url}" type="video/mp4">
</video>
""")

